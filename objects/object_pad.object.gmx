<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_pad</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///EXIT IF DOS ROOM
if (isDOSRoom(room)){
    visible =false;
    exit;
}
else{
    visible = true;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>object_pad</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CREATE
unique();
depth = CURSOR_DEPTH;
firstStep = false;
debug = true;
onSomething = false;
cursorMode = CURSOR_MODE_DEFAULT;
cursorModeParams = ds_list_create();
global.i[I_MODE] = -1;

lastCursor = array(noone, noone);

cursorSprite = sprite_cursor_idle;

mouseShift = array(0, 0);
freezeMouse = array(noone, noone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clear mouse shift
mouseShift = array(0,0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///EXIT IF PARALYZED
if (isParalyzed()){
    if (freezeMouse[0] == noone){
        freezeMouse = array(global.i[I_X], global.i[I_Y]);
    }
    for (i=1;i&lt;array_length_1d(key);i++){
        global.i[i] = 0;
    }
    exit;
}
else{
    if (freezeMouse[0] != noone){
        global.i[I_X] = freezeMouse[0];
        global.i[I_Y] = freezeMouse[1];
    }
    freezeMouse = array(noone, noone);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// xPadInput
if (gamepad_is_connected(0) || array_length_1d(global.i) &gt; 1){

    gamepad_set_axis_deadzone(0, 0.1);
    
    var gamepadInput = array(
        gamepad_axis_value(0, gp_axislh)*(0.1+getSetting("mouseSensitivity"))*XPAD_BASE_SENSITIVITY,
        gamepad_axis_value(0, gp_axislv)*(0.1+getSetting("mouseSensitivity"))*XPAD_BASE_SENSITIVITY
    );
    
    // Pressing X centers mouse on screen
    if (gamepad_button_check_pressed(0, gp_face3)){
        global.i[I_X] = view_xview+view_wview/2;
        global.i[I_Y] = view_yview+view_hview/2;
    }
    
    if (gamepad_button_check_pressed(0, gp_select)){
        toggleVisualKeyboard();
    }
    
    mouseShift = 
        array(
            gamepadInput[0] + mouseShift[0],
            gamepadInput[1] + mouseShift[1]
        );
        
    debugMe("GPI", gamepadInput);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input

//global.i[I_MODE] = 0; // FORCE MODE 0
if (debug &amp;&amp; firstStep)  show_debug_message("Input initialization...");


//CLAVIER*********************************************************************************************************
//Set mapping clavier------------------------------------------------------------------------------------------------

key_map[I_X] = window_mouse_get_x();
key_map[I_Y] = window_mouse_get_y();

key_map[I_ACTION] = mb_right;
key_map[I_SELECT] = mb_left;
key_map[I_ANCHOR_CAMERA] = mb_middle;
key_map[I_ADVANCED] = vk_control;
key_map[I_UP] = ord('Z');
key_map[I_DOWN] = ord('S');
key_map[I_LEFT] = ord('Q');
key_map[I_RIGHT] = ord('D');
key_map[I_MOVE_UP] = vk_up;
key_map[I_MOVE_DOWN] = vk_down;
key_map[I_MOVE_LEFT] = vk_left;
key_map[I_MOVE_RIGHT] = vk_right;
key_map[I_CONFIRM] = vk_enter;
key_map[I_PAUSE] = vk_escape;
key_map[I_SCROLL_UP] = noone;
key_map[I_SCROLL_DOWN] = noone;

// Hotkeys
key_map[I_1] = ord('1');
key_map[I_2] = ord('2');
key_map[I_3] = ord('3');
key_map[I_4] = ord('A');
key_map[I_5] = ord('E');
key_map[I_6] = ord('R');

key_map[I_BUILDINGS] = vk_alt;

xpad_map[I_ACTION] = gp_face2;
xpad_map[I_SELECT] = gp_face1;
xpad_map[I_ANCHOR_CAMERA] = gp_shoulderrb;
xpad_map[I_BUILDINGS] = gp_shoulderlb;
xpad_map[I_UP] = gp_padu;
xpad_map[I_DOWN] = gp_padd;
xpad_map[I_LEFT] = gp_padl;
xpad_map[I_RIGHT] = gp_padr;
xpad_map[I_PAUSE] = gp_start;
xpad_map[I_SCROLL_UP] = gp_padu;
xpad_map[I_SCROLL_DOWN] = gp_padd;

//// INPUT CHECKING

if (debug &amp;&amp; firstStep)  show_debug_message("Done !");
if (debug &amp;&amp; firstStep)  show_debug_message("Starting the Key Checking...");


// Mouse shift

mouseShift = array(
    mouseShift[0] +(key_map[I_X] - round(window_get_width()/2))*((1+getSetting("mouseSensitivity")*5)*MOUSE_BASE_SENSITIVITY),
    mouseShift[1] +(key_map[I_Y] - round(window_get_height()/2))*((1+getSetting("mouseSensitivity")*5)*MOUSE_BASE_SENSITIVITY)
);
   
// Keymapping
if (firstStep || array_length_1d(global.i) &lt;= 1){
    key[I_X] = key_map[I_X];
    key[I_Y] = key_map[I_Y];
}
else{
    key[I_X] = global.i[I_X]+mouseShift[0];
    key[I_Y] = global.i[I_Y]+mouseShift[1];
}

key[I_ACTION] = mouse_check_button_pressed(key_map[I_ACTION]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check_pressed(0, xpad_map[I_ACTION]));
key[I_SELECT] = mouse_check_button_pressed(key_map[I_SELECT]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check_pressed(0, xpad_map[I_SELECT]));
key[I_SELECT_HELD] = mouse_check_button(key_map[I_SELECT]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_SELECT]));
key[I_SELECT_RELEASED] = mouse_check_button_released(key_map[I_SELECT]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check_released(0, xpad_map[I_SELECT]));
key[I_ANCHOR_CAMERA_PRESSED] = mouse_check_button_pressed(key_map[I_ANCHOR_CAMERA]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check_pressed(0, xpad_map[I_ANCHOR_CAMERA]));
key[I_ANCHOR_CAMERA] = mouse_check_button(key_map[I_ANCHOR_CAMERA]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_ANCHOR_CAMERA]));
key[I_ADVANCED] = keyboard_check(key_map[I_ADVANCED]);
key[I_UP] = keyboard_check(key_map[I_UP]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_UP]));
key[I_DOWN] = keyboard_check(key_map[I_DOWN]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_DOWN]));
key[I_LEFT] = keyboard_check(key_map[I_LEFT]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_LEFT]));
key[I_RIGHT] = keyboard_check(key_map[I_RIGHT]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_RIGHT]));
key[I_ADVANCED] = keyboard_check(key_map[I_ADVANCED]);
key[I_MOVE_UP] = keyboard_check(key_map[I_MOVE_UP]);
key[I_MOVE_DOWN] = keyboard_check(key_map[I_MOVE_DOWN]);
key[I_MOVE_LEFT] = keyboard_check(key_map[I_MOVE_LEFT]);
key[I_MOVE_RIGHT] = keyboard_check(key_map[I_MOVE_RIGHT]);
key[I_CONFIRM] = keyboard_check_pressed(key_map[I_CONFIRM]);
key[I_PAUSE] = keyboard_check_pressed(key_map[I_PAUSE]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check_pressed(0, xpad_map[I_PAUSE]));
key[I_SCROLL_DOWN] = mouse_wheel_down() or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_SCROLL_DOWN]));
key[I_SCROLL_UP] = mouse_wheel_up() or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_SCROLL_UP]));

// Hotkeys
key[I_1] = keyboard_check_pressed(key_map[I_1]);
key[I_2] = keyboard_check_pressed(key_map[I_2]);
key[I_3] = keyboard_check_pressed(key_map[I_3]);
key[I_4] = keyboard_check_pressed(key_map[I_4]);
key[I_5] = keyboard_check_pressed(key_map[I_5]);
key[I_6] = keyboard_check_pressed(key_map[I_6]);

key[I_BUILDINGS] = keyboard_check(key_map[I_BUILDINGS]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check(0, xpad_map[I_BUILDINGS]));
key[I_BUILDINGS_RELEASED] = keyboard_check_released(key_map[I_BUILDINGS]) or (gamepad_is_connected(0) &amp;&amp; gamepad_button_check_released(0, xpad_map[I_BUILDINGS]));

if (debug &amp;&amp; firstStep)  show_debug_message("Done !");
if (debug &amp;&amp; firstStep)  show_debug_message("Injecting input into Global...");

//Global injection -----------------------------------------------------------------------------------------
for (i=1;i&lt;array_length_1d(key);i++){
     global.i[i] = key[i];
}

if (debug &amp;&amp; firstStep)  show_debug_message("Done !");
if (debug &amp;&amp; firstStep)  show_debug_message("Follows.");


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset mouse position in the center of the screen &amp;&amp; clamp
global.i[I_X] = clamp(global.i[I_X], view_xview, view_xview+view_wview);
global.i[I_Y] = clamp(global.i[I_Y], view_yview, view_yview+view_hview);

window_mouse_set(window_get_width()/2, window_get_height()/2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///EXIT IF PARALYZED
if (isParalyzed()){
    
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EXIT IF PAUSED OR NOT INGAMe
if (object_game.paused || !object_game.inGame || notAGameRoom(room)){
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MOUSE
cursorSprite = sprite_cursor_idle;

var cannot = false;

var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
var nearestEmmet = instance_nearest(pos[0], pos[1], object_emmet);

if (cursorModeGet() == CURSOR_MODE_DEFAULT){
    
    var cursor = object_gridman.cursorIsoIndex;
    var eSL = object_masterselector.emmetSelectionRange;
    
    /// De-color
    var buildingCol = onChunk(lastCursor, object_building_parent);
    
    if (wallExists(lastCursor) &amp;&amp; !isSelectedWall(lastCursor)){
        revertWallColor(lastCursor);
    }
    else if (instance_exists(buildingCol)){
        buildingCol.hovered = false;
    }
    
    /// Color
    if (isVisible(cursor) &amp;&amp; 
        isInGrid(cursor) &amp;&amp; 
        !isSelectedGravel(cursor) &amp;&amp;
        !isSelectedWall(cursor) &amp;&amp;
        !array_equals(cursor, object_masterselector.selection)){
        
        var buildingCol = onChunk(cursor, object_building_parent);
        var emmetCol = collision_circle(displayToSysX(global.i[I_X]-eSL/2, global.i[I_Y]), 
                                    displayToSysY(global.i[I_X]-eSL/2, global.i[I_Y]), 
                                    eSL,
                                    object_emmet, 
                                    false, 
                                    false);
        if (instance_exists(emmetCol)){
            // nothing to do
        }
        /// Shotgun wall selection
        else if (wallExists(cursor) || wallExists(array(cursor[0]+1, cursor[1]+1))){
            
            if (global.terrain_walls[# cursor[0], cursor[1]] != TERRAIN_WALL_UNBREAKABLE){
            /// Walls
                var possibleWalls = array(cursor, array(cursor[0]+1, cursor[1]+1)); /// List of possible selectable walls
                
                for (var i = 0; i &lt; array_length_1d(possibleWalls); i++){
                    var wall = possibleWalls[i];
                    
                    if (i == 1){
                        var rawCursor = array(displayToSysX(global.i[I_X], global.i[I_Y])/G_CELLSIZE, displayToSysY(global.i[I_X], global.i[I_Y])/G_CELLSIZE);
                        if (point_distance(wall[0], wall[1], rawCursor[0], rawCursor[1]) &gt; 0.66){
                            continue;
                        }
                    }
                    if (global.terrain_walls[# wall[0], wall[1]] != TERRAIN_WALL_CLEAR &amp;&amp;
                            isSelectableWall(wall) &amp;&amp;
                            !isSelectedWall(wall)){
                    /// WALL SELECTION
                        terrain_set_colour(global.terrain_walls, wall[0], wall[1], hoverColor());
                        cursor = wall;
                    }
                }
            }
            else{
                revertWallColor(cursor);
                cannot = true;
            }
                
        }
        else if (instance_exists(buildingCol)){
            buildingCol.hovered = true;
        }
        else{
            colorChunk(cursor, hoverColor(), 0.3);
        }
        lastCursor = cursor;
    }
}
else if (cursorModeGet() == CURSOR_MODE_BUILD){
    
    var cursor = object_gridman.cursorIsoIndex;
    if (isVisible(cursor)){
        var size = getBuilding(ds_list_find_value(cursorModeParams, 0), "size");
        var ci = growToRoom(cursor, size);
        
        var valid = true;
        
        //SECURE SELECTION
        for (var i = 0; i &lt; array_length_1d(ci); i++){
            if (i%2 == 0){
                ci[i] = clamp(ci[i], 0, ds_grid_width(global.terrain));
            }
            else{
                ci[i] = clamp(ci[i], 0, ds_grid_height(global.terrain));
            }
        }
        //ENDOF
        
        for (var i = ci[0]; i &lt; ci[2]; i++){
            for (var j = ci[1]; j &lt; ci[3]; j++){
                var thisCi = array(i,j);
                
                if (!canBuildOn(ds_list_find_value(cursorModeParams, 0), thisCi)){
                    valid = false;
                    colorChunk(thisCi, c_red, 0.3);
                }
                else{
                    colorChunk(thisCi, c_lime, 0.3);
                }
            }
        }
        
        var poss = getSurroundingsIndex(object_gridman.cursorIsoIndex, getBuilding(ds_list_find_value(cursorModeParams, 0), "size"));
        
        for (var i = 0; i &lt; array_length_1d(poss); i++){
        
            var thisPos = poss[i];
            
            thisPos = clampSelect(thisPos, object_game.gridSize);
            
            if (!valid || !isVisible(thisPos) || !canBuildOn(object_ground_pathway, thisPos)){
                colorChunk(thisPos, c_red, 0.3);
            }
            else{
                colorChunk(thisPos, c_yellow, 0.3);
            }
        }
        
        if (global.i[I_SELECT] &amp;&amp; 
            valid &amp;&amp;
            !isOccupied(object_gridman.cursorIsoIndex) &amp;&amp;
            isVisible(object_gridman.cursorIsoIndex)){
            
            clearSelection();
            
            teleportBuilding(ds_list_find_value(cursorModeParams, 0), 
                        array(object_gridman.cursorIsoIndex[0]*G_CELLSIZE, 
                                object_gridman.cursorIsoIndex[1]*G_CELLSIZE));
            playSfx(sound_sfx_select);
                                
            cursorModeSet();
        }
    }
}

if (global.i[I_ACTION]){
    cursorModeSet();
}
if (instance_exists(object_debug) &amp;&amp; 
    object_debug.debug &amp;&amp; 
    cursorModeGet() == CURSOR_MODE_DEBUG){
    
    colorChunk(getIsoIndex(displayToSys(array(global.i[I_X], global.i[I_Y]))),  merge_colour(c_fuchsia, c_lime, get_timer()/400000), 0.5);
    
    if (global.i[I_SELECT]){
        object_debug.subMenu = -1;
        switch (object_debug.debugCursor){                
        
            case "[M] Create explosion":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                instance_create(pos[0], 
                                pos[1], 
                                object_explosion_fx);
                break;    
        
            case "[M] Spawn...":
                var amount = ds_list_find_value(object_debug.parameters, 0);
                var rsc = ds_list_find_value(object_debug.parameters, 1);
                var obj = getRessource(rsc, "object");
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                for (var i = 0; i &lt; amount; i++){
                    instance_create(pos[0]+random(G_CELLSIZE), 
                                    pos[1]+random(G_CELLSIZE), 
                                    obj);
                }
                break;
                
            case "[M] Liberate 1 of each":
                var rsc = getRessources();
                var needs = ds_map_logcreate();
                for (var i = 0; i &lt; array_length_1d(rsc); i++){
                    ds_map_add(needs, rsc[i], 1);
                }
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                liberateRsc(needs, instance_nearest(pos[0], pos[1], object_building_stocker));
                ds_map_logdestroy(needs);
                break;
            
            case "[M] Spawn Vision Explorer":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                instance_create(pos[0], pos[1], object_vision_explorer);
                break;
                
            
            case "[M] Teleport back":
                teleportBack(onChunk(object_gridman.cursorIsoIndex, object_building_parent));
                break;
                
            case "[M] Power switch":
                var col = onChunk(object_gridman.cursorIsoIndex, object_building_parent);
                if (instance_exists(col)){
                    col.powered = !col.powered;
                }
                break;
                
            case "[M] Liberate...":
                var amount = ds_list_find_value(object_debug.parameters, 0);
                var rsc = ds_list_find_value(object_debug.parameters, 1);
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var needs = ds_map_logcreate();
                ds_map_add(needs, rsc, amount);
                liberateRsc(needs, instance_nearest(pos[0], pos[1], object_building_stocker));
                break;
                
            case "[M] Spawn EM Explorer":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                instance_create(pos[0], pos[1], object_electromagnetical_scrambler_explorer);
                break;
                
            case "[M] Spawn emmet":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                instance_create(pos[0], pos[1], object_emmet);
                break;
                
            case "[M] Spawn Yard...":
                var object = ds_list_find_value(object_debug.parameters, 0);
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                addBuilding(object, pos);
                break;
                
            case "[M] Spawn building...":
                var object = ds_list_find_value(object_debug.parameters, 0);
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var inst = instance_create(pos[0], pos[1], object);
                inst.initialized = true;
                inst.firstStep = false;
                inst.arriving = 0;
                inst.hasFoldedPathways = true;
                break;
                
            case "[M] Teleport building...":
            
                var object = ds_list_find_value(object_debug.parameters, 0);
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                instance_create(pos[0], pos[1], object);
                break;
                
            case "[M] Damage...":
                var damageAmnt = ds_list_find_value(object_debug.parameters, 0);
                var col = onChunk(object_gridman.cursorIsoIndex, object_building_parent);
                if (instance_exists(col)){
                    col.actHp -= damageAmnt;
                }
                break;
                
            case "[M] Spawn Visible Explorer...":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var explorer = instance_create(pos[0], pos[1], object_vision_explorer);
                explorer.debugSpeed = ds_list_find_value(object_debug.parameters, 0);
                break;
                    
            case "[M] Delete RSC":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var nr = instance_nearest(pos[0], pos[1], object_pickable);
                if (point_distance(nr.x, nr.y, pos[0], pos[1]) &lt; 1){
                    with (nr){
                        instance_destroy();
                    }
                }
                break;
            
            case "[M] Spawn NRG Explorer...":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var nrgx = instance_create(pos[0], pos[1], object_energy_explorer);
                nrgx.debugSpeed = ds_list_find_value(object_debug.parameters, 0);
                nrgx.visible = ds_list_find_value(object_debug.parameters, 1);
                break;
                
            case "[M] Create floating number":
                floatingNumbers(array(mouse_x, mouse_y), numberFormat(124673), c_lime);
                break;
                
            case "[M] Spawn Dynamite":
                instance_create(displayToSysX(mouse_x, mouse_y), displayToSysY(mouse_x, mouse_y), object_triggered_dynamite);
                break;
        
        }
    }
    /// BRUSH MODE (hold and draw)
    else if (global.i[I_SELECT_HELD]){
        switch (object_debug.debugCursor){
            
            case "[M] Draw NRG Pathways":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                if (!onChunk(getIsoIndex((pos)), object_ground)){
                    instance_create(pos[0], pos[1], object_ground_pathway);
                }
                break;   
            
            case "[M] Draw gravel":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var loot = ds_map_logcreate();
                ds_map_add(loot, "crystal", 4);
                addGravel(getIsoIndex(pos), loot);
                break;
            
            case "[M] Clear ground":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var ii = getIsoIndex(pos);
                var col = onChunk(ii, object_ground);
                if (instance_exists(col)){
                    with (col){
                        instance_destroy();
                    }
                }
                else if getGravel(ii) != noone{
                    remGravel(ii);
                }
                break;
                
            case "[M] Add dirt wall":
                addWall(object_gridman.cursorIsoIndex, TERRAIN_WALL_DIRT);
                break;
                
            case "[M] Add hard wall":
                addWall(object_gridman.cursorIsoIndex, TERRAIN_WALL_HARDROCK);
                break;
                
            case "[M] Kill emmet":
                var pos = displayToSys(array(global.i[I_X], global.i[I_Y]));
                var col = collision_point(pos[0], pos[1], object_emmet, false, false);
                if (instance_exists(col)){
                    col.dead = true;
                }
                break;
        
            case "[M] Add unbreakable":
                addWall(object_gridman.cursorIsoIndex, TERRAIN_WALL_UNBREAKABLE, false);
                break;
                
            case "[M] Destroy wall":
                destroyWall(object_gridman.cursorIsoIndex);
                break;
                
            case "[M] Remove wall":
                remWall(object_gridman.cursorIsoIndex);
                break;
                
            case "[M] Destroy pathway":
                destroyPathway(onChunk(object_gridman.cursorIsoIndex, object_ground_pathway));
                break;
        }
    }
    else{
        //HOVER MODE
        switch (object_debug.debugCursor){
        
            case "[M] Debug emmet IAI":
                var col = collision_point(displayToSysX(global.i[I_X], global.i[I_Y]), displayToSysY(global.i[I_X], global.i[I_Y]), object_emmet, false, false);
                if (instance_exists(col)){
                    col.debugIAI = true;
                }
                break;
        }
    
    }
}

if (object_cameraman.cameraAnchored){
    cursorSprite = sprite_cursor_movecamera;
}
else if (cannot){
    cursorSprite = sprite_cursor_no;
}
/*
else if (hotlink) {
    cursor = sprite_cursor_hotlink;
}
*/

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///TIPS
////////////////////////
///
/// TIPS
///
////////////////////////

if (instance_exists(object_tipsman) &amp;&amp; object_tipsman.tipText != ""){
    //do nothing
}
/// Resources and oxygen from the headband
else if (object_headband.hoveredRsc != noone){
    if (isBuildingMaterial(object_headband.hoveredRsc)){
        var text = string_replace_all(translate("LORE", object_headband.hoveredRsc), "%s", translate("RSC", object_headband.hoveredRsc));
        drawTip(text);
    }
    else{
        var text = translate("UI_TIP", object_headband.hoveredRsc);
        drawTip(text);
    }
}
else if (object_headband.hoveredOxygen){
    var text = translate("UI_TIP", "oxygen");
    drawTip(text);
}
/// Selectedmenu Items
else if (   object_selectedmenu.hoveredItem &gt;= 0 &amp;&amp; 
            object_selectedmenu.hoveredItem &lt; array_length_1d(object_selectedmenu.menuItems) &amp;&amp; 
            object_selectedmenu.menuItems[object_selectedmenu.hoveredItem] != noone
        ){
    var text = translate("ITEM_TIP", object_selectedmenu.menuItems[object_selectedmenu.hoveredItem]);
    
    drawTip(text);
}
else if (object_selectedmenu.makeTip != ''){
    drawTip(object_selectedmenu.makeTip);
}
/// Yards
else if (onChunk(object_gridman.cursorIsoIndex, object_building_yard)){
    var col = onChunk(object_gridman.cursorIsoIndex, object_building_yard);
    if (instance_exists(col) &amp;&amp;  col.object_index == object_building_yard){
        cursorColor = c_lime;
        
        var text = translateBuilding(getYardObjective(col));
        var needs = getYardNeeds(col);
        var current = getYardFunds(col);
        var ressources = getRessources();
        for (var i = 0; i &lt; array_length_1d(ressources); i++){
            var needOfThis = ds_map_find_value(needs, ressources[i]);
            if (needOfThis &gt; 0){
                text += "#"+translateRessource(ressources[i])+" : "+string(ds_map_find_value(current, ressources[i]))+"/"+string(needOfThis);
            }
        }
        drawTip(text);
    }
}

/// Buildings
else if (onChunk(object_gridman.cursorIsoIndex, object_building_parent)){
    var col = onChunk(object_gridman.cursorIsoIndex, object_building_parent);
    if (instance_exists(col)){
        cursorColor = c_lime;
        
        var text = translate(BUILDING, object_get_name(col.object_index))+"#";
        var actHp = col.actHp;
        text = text + string(floor((actHp/100)*100))+" HP";
        drawTip(text);
    }
}

/// Emmets
else if (instance_exists(nearestEmmet) &amp;&amp; point_distance(pos[0], pos[1], nearestEmmet.x, nearestEmmet.y) &lt; 5){
    var hisName = "Emmet";
    if (nearestEmmet.name != ""){
        hisName = nearestEmmet.name;
    }
    var fString = hisName + "#"+ string(nearestEmmet.actHp) +"%";
    drawTip(fString);
}
//end of 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// F1 For help
if (keyboard_check_pressed(vk_f1) &amp;&amp; !notAGameRoom(room) &amp;&amp; !object_game.paused){
    showHelp();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//GAMEPAD PLUG
/*
switch(async_load[? "event_type"])             // Parse the async_load map to see which event has been triggered
{
    case "gamepad discovered":                     // A game pad has been discovered
        var pad = async_load[? "pad_index"];       // Get the pad index value from the async_load map
        if (global.i[I_MODE] == -1){
                pad[I_MODE] = pad;
        }
        break;
    case "gamepad lost":                           // Gamepad has been removed or otherwise disabled
        var pad = async_load[? "pad_index"];       // Get the pad index
        if (global.i[ I_MODE] == pad){
            pad[I_MODE] = -1;
        }
    break;
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mouse selector

if (isDOSRoom(room) ){
    window_set_cursor(cr_none);
    exit;
}


cursorScale = getSetting("cursorScale")*3 + 1;
if (cursorMode == CURSOR_MODE_DEFAULT){
    cursorColor = c_white;
}
else if (cursorMode == CURSOR_MODE_BUILD){
    if (isOccupied(object_gridman.cursorIsoIndex)){
        cursorColor = selectionColor(0, c_maroon);
    }
    else{
        cursorColor = selectionColor(0, c_lime);
    }
}
else if (cursorMode == CURSOR_MODE_DEBUG){
    cursorColor = merge_colour(c_fuchsia, c_lime, get_timer()/400000);
}

//Cursor, always drawn at end;

if (isOnScreen(global.i[I_X], global.i[I_Y])){
    window_set_cursor(cr_none);
    var position = array(global.i[I_X], global.i[I_Y]);
    if (isParalyzed()){
        position = freezeMouse;
    }
    if (getSetting("fastCursor")){
        position = array(mouse_x, mouse_y);
    }
    draw_sprite_ext(cursorSprite, 0, position[0], position[1], cursorScale, cursorScale, 0, cursorColor, 1);
}

//ENDING
onSomething = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
